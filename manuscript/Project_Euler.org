#+TITLE: Getting Started with the R Language: Solving Project Euler Problems to learn to code
#+TODO: TODO DRAFT EDITED FINAL
#+STARTUP: overview
#+PROPERTY: header-args:R :session *R* :results value raw :exports both
#+LATEX_HEADER: \usepackage{times} \usepackage{mathptmx}


* Overview

| Problem    | Topic                   | R        |
|------------+-------------------------+----------|
| Problem 1  | arithmetic progression  | Basics   |
|            | Guass anecdote          |          |
|            | Brute force vs analytic | Vector   |
|            | Fizzbuz                 | for-loop |
|------------+-------------------------+----------|
| Problem 2  | Fibonacci numbers       | while    |
|            |                         |          |
|            |                         |          |
|------------+-------------------------+----------|
| Problem 3  | Prime factors           |          |
|            | No analytical method    |          |
|            | Encryption              |          |
|            |                         |          |
|------------+-------------------------+----------|
| Problem 4  | Palindromic numbers     |          |
|            | Lychrel numbers         |          |
|            | Recreational math       |          |
|------------+-------------------------+----------|
| Problem 5  |                         |          |
|            |                         |          |
|            |                         |          |
|------------+-------------------------+----------|
| Problem 6  |                         |          |
|            |                         |          |
|            |                         |          |
|------------+-------------------------+----------|
| Problem 7  |                         |          |
|            |                         |          |
|            |                         |          |
|------------+-------------------------+----------|
| Problem 8  |                         |          |
|            |                         |          |
|            |                         |          |
|------------+-------------------------+----------|
| Problem 9  |                         |          |
|            |                         |          |
|------------+-------------------------+----------|
| Problem 10 |                         |          |
|            |                         |          |
|------------+-------------------------+----------|
* Problem 1: Sum of an Arithmetic Sequence
* Problem 2: Even Fibonacci Numbers
The second Project Euler problem looks at the Fibonacci numbers. 

- Who was Fibonaci
- Rabbits

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

This problem asks to find the sum of all even Fibonacci numbers less than four million.

This number sequence describes many natural processes, such as the patterns in this beautiful sunflower. The seeds inside the sunflower grow in a spiral pattern and the number of spirals tends to be a Fibonacci number. This pattern is the most efficient way to pack the centre with as many seeds as possible.

Famous mathematician and father of computer science Alan Turing was fascinated by this problem until his death. In 2016, the Royal Society published a journal article that builds on his work in the Open Science journal. They collected sunflowers from citizen scientists from around the world and confirmed that for the majority of sunflowers, the number of spirals is a Fibonacci number. They did, however, also discover other patterns. Euler Problem 2 is a bit less poetic as it only asks to generate and sum numbers.
** More about loops
The first problem introduced using the for-loop to cycle through a series of numbers. The R language has several other ways to cycle 

The code generates Fibonacci numbers until it reaches the value of four million. The code then sums the even numbers in the sequence. Because the Fibonacci sequence requires you to add the previous two number, the first two numbers in the sequence need to be defined (1 and 2). The fib variable is a collection, indicated with the letter =c=. A collection in R can be used to store a sequence of numbers or words.

:NOTES:
Don't append collections!
:END:

#+BEGIN_SRC R
  fib <- c(1, 1)
  while (max(fib) < 4E+06) {
      len <- length(fib)
      fib <- c(fib, fib[len - 1] + fib[len])
  }
  answer <- sum(fib[fib %% 2 == 0])
  print(answer)
#+END_SRC

Concatenating a collection in a loop is generally frowned-upon in R programming. This approach is a relatively slow solution because all previous values are rewritten at every iteration. In a future problem we will use lists to avoid this issue.
*** Specialised packages
One of the major advantages of using R are the thousands of specialised packages that can be used to solve specific problems. There are packages that extend the mathematical capabilities of R, etc etc.

A series of R packages exist that generate Fibonacci numbers. The [[https://cran.r-project.org/web/packages/gmp/index.html][GMP package]] for Multiple Precision Arithmetic provides a function to calculate any Fibonacci number. This package is also able to work with huge numbers with hundreds or thousands of digits. Using this package is much faster than the base R code used above.

Before you can start using this package you will need to install it. 

#+BEGIN_SRC R
install.packages("gmp")
#+END_SRC

#+BEGIN_SRC R :tangle problem002.R :results output
  ## GNU Multiple Precision Arithmetic Library
  library(gmp)
  i <- 1
  answer <- 0
  fib <- fibnum(i)
  while (fib <= 4E6) {
      if (fib %% 2 == 0) {
          answer <- answer + fib
          }
      i <- i + 1
      fib <- fibnum(i)
      }
  print(answer)
#+END_SRC

#+RESULTS:
: Big Integer ('bigz') :
: [1] 4613732
*** Analytical solution
This problem can also be solved in one step by using an analytical approach.

Binet:

$$F_n=\frac{\varphi^n-\frac{1}{(-\varphi)^n}}{\sqrt{5}}$$

We know that $\varphi$ is the Golden Ratio, so we can simplify this formula:

$$F_n\sqrt{5}=\frac{(1+\sqrt{5})^n}{2^n}$$

The inverse of the Binet formula gives us:[fn:binet]

$n=\left[ \log_\phi \sqrt{5}(F_n-\frac{1}{2}) \right]$ holds for all $n\ge 3$

[fn:binet] Vadim Ponomarenko, [[https://math.stackexchange.com/questions/374758/how-can-i-find-an-inverse-to-the-binet-formula][fibonacci numbers - How can I find an inverse to the Binet formula? - Mathematics Stack Exchange]]

Using this formula, we find that the first 33 Fibonacci numbers are equal or less than four million. Next step is to sum all the even numbers.

https://www.youtube.com/watch?v=Cspq_vvScV8

Summing a series of sequential Fibonacci numbers is straighforward because the sequence consists of sums. The sum of all Fibonacci numbers is:

$$ = F_{n+2} - 1$$

According to the [[https://oeis.org/A014445][Online Encyclopedia of Integer Sequences]] (lemma A014445), every third Fibonacci number is even.

The sum of all even Fibonacci numbers is given by $\sum_{i=1}^{n} F_{2i} = F_{2n+1} -1$$.

* Problem 3: Largest Prime Factor
Euler problem 3 is about prime factors, which are some of the most important numbers of the digital economy. RSA encryption is based on the fact that determining the prime factors of huge numbers takes a very long time. So much time in fact that the cost of breaking the encryption outweigh the benefits of obtaining the secret.

[[https://r.prevos.net/tag/primes/][Prime numbers]] are the basic building blocks of the natural numbers as every number, except the primes themselves. Every natural number can be written as the product of a series of primes. The RSA encryption system uses large primes to keep electronic messages away from prying eyes, as explained in the Numberphile video below.

https://www.youtube.com/watch?v=M7kEpw1tn50

** Euler Problem 3 Definition
The prime factors of 13195 are 5, 7, 13 and 29. What is the [[https://projecteuler.net/problem=3][largest prime factor of the number 600851475143]]?
** Generating Prime Numbers
This solution relies on two functions that can be used for multiple Euler problems. The [[https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes][Sieve of Eratosthenes]] generates prime numbers from 2 to /n/. The code is commented to explain the sieve and the image shows how numbers from 1 to 100 are sieved to find the primes.

https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#/media/File:Sieve_of_Eratosthenes_animation.gif
#+caption: Sieve of Eratosthenes.

The =prime.factors= function generates the list of unique prime divisors and then generates the factors. The factors are identified by dividing the number by the candidate prime factors until the result is 1.

The solution can also be found by using the =primeFactors= function in the [[https://cran.r-project.org/web/packages/numbers/index.html][numbers]] package, which provides a range of functions related to prime numbers and is much faster than the basic code provided above.

The most recent version of this code is available on [[https://github.com/pprevos/r.prevos.net/blob/master/ProjectEuler/problem003.R][GitHub]].

#+BEGIN_SRC R :results output :tangle problem003.R
  ## Euler Problem 3: Largest prime factor
  ## https://r.prevos.net/euler-problem-3/
  esieve <- function(n) {
      if (n == 1) return(NULL)
      if (n == 2) return(n)
      ## Create a list of consecutive integers {2,3,â€¦,N}.
      l <- 2:n
      ## Start counter
      i <- 1
      ## Select p as the first prime number in the list, p=2.
      p <- 2
      while (p^2 <= n) {
          ## Remove all multiples of p from the l.
          l <- l[l == p | l %% p!= 0]
          ## set p equal to the next integer in l which has not been removed.
          i <- i + 1
          ## Repeat steps 3 and 4 until p2 > n,
          ## all the remaining numbers in the list are primes
          p <- l[i]
      }
      return(l)
  }

  prime.factors <- function (n) {
      ## Define list of factors
      factors <- c()
      ## Define primes to be tested
      primes <- esieve(floor(sqrt(n)))
      ## Idenitfy prime divisors
      d <- which(n %% primes == 0) 
      ## No prime divisors
      if (length(d) == 0) 
          return(n)
      ## Test candidate primes
      for (q in primes[d]) {
          ## Generate list of factors
          while (n %% q == 0) {
              factors <- c(factors, q)
              n <- n/q } }
      if (n > 1) factors <- c(factors, n)
      return(factors)
  }

  max(prime.factors(600851475143))

  ## Using number package
  library(numbers)
  max(primeFactors(600851475143))
#+END_SRC

#+RESULTS:
[1] 6857
Error in library(numbers) : there is no package called â€˜numbersâ€™
Error in primeFactors(600851475143) : 
  could not find function "primeFactors"


-------------------------------------------------------------------------------
* Problem 4: Largest Palindromic Product
** Euler Problem 4 Definition
A palindromic number reads the same both ways. The largest [[https://en.wikipedia.org/wiki/Palindromic_number][palindrome]] made from the product of two 2-digit numbers is 9009 = 91 Ã— 99. Find the [[https://projecteuler.net/problem=4][largest palindrome]] made from the product of two 3-digit numbers.
** Solution
This code searches fo palindromic numbers, starting at the highest values. The palindromes are tested by converting the number to a character string. When the first palindromic number is found, the loop is broken.

Searching a bit further results in twelve palindromic numbers. Sequence A002113 in the OEIS lists palindromes in base 10. Mathematicians used these numbers only for fun, without any purpose in reality. The graph below shows the number of palindromic numbers between 0 and 1 million.

#+BEGIN_SRC R :tangle problem004.R :results output graphics :file Images/problem004.png
  ## Euler Problem 4: Largest palindrome product
  ## https://projecteuler.net/problem=4
  library(tidyverse)

  palindrome <- function(x) {
      ## Convert to character
      word <- as.character(x)
      ## Create reverse
      reverse <- paste(rev(unlist(strsplit(word, ""))), collapse = "")
      ## Check whether palindrome
      return(word == reverse)
  }

  for (i in 999:900) {
      for (j in 990:900) {
          p <- i * j
          if (palindrome(p)) 
              break
      }
      if (palindrome(p)) {
          break
      }
  }
  answer <- i * j
  print(answer)

  ## A002113 Palindromes in base 10
  p_max <- 1.5E5
  A002113 <- which(lapply(1:p, palindrome) == TRUE)
  data_frame(x = 1:p_max,
             y = sapply(1:p_max, function(p) length(A002113[A002113 < p]))
             ) %>%
      ggplot(aes(x, y)) + geom_line() +
      xlab("n") + ylab("Palindromic numbers <n")
  ggsave("Images/problem004.png", dpi = 300)
#+END_SRC	

#+RESULTS:
[[file:Images/problem004.png]]
* Problem 5: Smallest Multiple
Euler Problem 5 relates to the divisibility of numbers.
** Euler Problem 5
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
** Solution
The solution will also be divisible by the number 1 to 10 so we can start at 2520 and increment by 2520. The loop checks whether the number is divisible by the numbers 1 to 20.
#+BEGIN_SRC R :tangle problem005.R
## Euler Problem 5: Smallest Multiple
## https://projecteuler.net/problem=4
i <- 2520
while (sum(i %% (1:20)) != 0) {
    i <- i + 2520
}
answer <- i
print(answer)
#+END_SRC

#+RESULTS:
: 232792560

The most recent version of this code is available on [[https://github.com/pprevos/r.prevos.net/blob/master/ProjectEuler/problem005.R][GitHub]].

#+BEGIN_SRC R :tangle problem005.R
## Analytical solution by David Radcliffe
## Euclidean algorithm
gcd <- function (x, y) ifelse(x == 0, y, gcd(y %% x, x))
lcm <- function (x, y) x * y / gcd(x,y)
print(Reduce(lcm, 1:20))
#+END_SRC

#+RESULTS:
: 232792560
* Problem 8: Largest product in a series
#+BEGIN_SRC R :tangle problem008.R
  ## Euler Problem 8: Largest product in a series
  ## https://projecteuler.net/problem=8
  library(rvest)
  digits <- read_html("https://projecteuler.net/problem=8") %>%
      html_nodes("p") %>%
      html_text() 
  digits <- gsub("[^0-9\\.]", "", digits[2])

  ngram <- 13 # Define length
  answer <- 0
  ## Clycle through digits
  for (i in 1:(nchar(digits) - ngram + 1)) {
      ## Pick 13 consecutive digits
      adjecent <- substr(digits, i, i + ngram - 1)
      ## Define product
      mult <- prod(as.numeric(unlist(strsplit(adjecent, ""))))
      ## Largest?
      if (mult > answer) answer <- mult
  }
  print(answer)
#+END_SRC

#+RESULTS:
: 23514624000
* Problem 6: Euler Problem 6: Sum Square Difference
** Euler Problem 6 Definition
The sum of the squares of the first ten natural numbers is:

$1^2 + 2^2 + \ldots + 10^2 = 385$

The square of the sum of the first ten natural numbers is:

$(1 + 2 + \ldots + 10)^2 = 552 = 3025$

The difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025 - 385 = 2640$. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
** Solution
This is a straightforward problem for vector processing capabilities in R.

#+BEGIN_SRC R :tangle problem006.R :results output 
  ## Euler Problem 6: Sum Square Difference
  ## https://projecteuler.net/problem=6

  ## Brute force
  n <- 100
  answer <- sum(1:n)^2-sum((1:n)^2)
  print(answer)

  ## Analytical
  answer <- ((n*(n+1))/2)^2 - (n*(n+1)*(2*n+1))/6
  print(answer)
#+END_SRC

#+RESULTS:
: [1] 25164150
: [1] 25164150

This problem can also be solved arithmetically. When Carl Friedrich Gauss (1777-1855) when he was a child his teacher challenged his students to add all numbers from 1 to 100. All of his friends struggled to add all the 100 numbers one by one but Carl completed the task in a few seconds.

The same principle applies to computing. The first solution is like Carl's classmates who slavishly add all numbers. This solution is based on arithmetic progressions.

The sum of natural numbers can be expressed as:
$latex \frac{n(n + 1)}{2} &s=2$

The sum of the squares of the first n natural numbers is:
$latex \frac{n(n+1)(2n+1)}{6} &s=2$

With these two formulas, a fast solution without having to use loops can be written.

This code on [[https://github.com/pprevos/r.prevos.net/blob/master/ProjectEuler/problem006.R][GitHub]].
* Problem 7: 10,001st Prime
** Euler Problem 7 Definition
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13. What is the 1,0001st prime number?
** Solution
The =is.prime= function determines whether a number is a prime number by checking that it is not divisible by any prime number up to the square root of the number.

The Sieve of used in Euler Problem 3 is reused to generate prime numbers.

This problem can only be solved using brute force because prime gaps (sequence A001223 in the OEIS) do not follow a predictable pattern.

#+BEGIN_SRC R :tangle problem007.R :results output 
  ## Euler Problem 7: 10,001st Prime
  ## https://projecteuler.net/problem=7

  source("euler.R")
  is.prime <- function(n) {
      primes <- esieve(ceiling(sqrt(n)))
      prod(n %% primes!=0)==1
  }

  i <- 2 # First Prime
  n <- 1 # Start counter
  while (n < 10001) { # Find 10001 prime numbers
      i <- i + 1 # Next number
      if(is.prime(i)) { # Test next number
          n <- n + 1 # Increment counter
          i <- i + 1 # Next prime is at least two away
      }
  }
  answer <- i - 1
  print(answer)

  ## Visualise
  primes <- esieve(answer)
  gaps <- primes[2:10001] - primes[1:10000]

  library(tidyverse)

  data_frame(gap = gaps) %>%
      ggplot(aes(gap)) +
      geom_histogram(binwidth = 1, fill = "dodgerblue3") +
      xlab("Prime gap occurence")
  ggsave("Images/problem007.png", dpi = 300)
#+END_SRC	

#+RESULTS:

The largest prime gap for the first 10,001 primes is 72. Sexy primes with a gap of 6 are the most common and there are 1270 twin primes.

You can also view this code on GitHub.
* Problem 8: Largest Product in a Series
Euler Problem 8 combines mathematics with text analysis. Just like problem 11, it asks for the largest product. The problem is defined as follows: The four adjacent digits in the 1,000-digit number below that have the greatest product are 9 \times 9 \times 8 \times 9 = 5832.

7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

Find the thirteen adjacent digits in the 1,000-digit number that have the greatest product. What is the value of this product?
Euler Problem 8 Proposed Solution

The first step is to define the digits as a character string. The answer is found by cycling through all 13-character n-grams to find the highest product using the prod function. You can download the most recent version of this code from GitHub.

#+BEGIN_SRC R
# Define digits
digits <- "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"
ngram <- 13 # Define length
answer <- 0
# Clycle through digits
    for (i in 1:(nchar(digits) - ngram + 1)) {
    # Pick 13 consecutive digits
    adjecent <- substr(digits, i, i + ngram - 1)
    # Define product
    mult <- prod(as.numeric(unlist(strsplit(adjecent, "")))) # Largest? 
    if (mult > answer)
        answer <- mult
}
#+END_SRC
* Problem 9: Special Pythagorean Triple
Euler Problem 9 is about the ancient problem or Pythagorean triples. My background is in carpentry and the basic Pythagorean triple 3:4:5 is a common tool to check whether an angle is straight. When building a structure, simply mark 3 and 4 units of length on the two sides and check whether the diagonal is exactly five units to ensure your angles are straight. There are, however, an infinite number of triples that form right angles.
Euler Problem 9 Definition

A Pythagorean triple is a set of three natural numbers, a < b < c, for which, a^2 + b^2 = c^2. For example: 3^2 + 4^2 = 9 + 16 = 25 = 5^2. There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product of a, b and c.
Brute Force Solutions

This solution uses brute force and checks all combinations of a, b and c. To limit the solution space I used the fact that a < b < c, which implies that a < s/3,  and a < b < s/2, where s is the sum of the three sides.
	
a <- 0
b <- 0
c <- 0
s <- 1000
found <- FALSE
for (a in 1:floor((s / 3))) {
    for (b in a:(s / 2)) {
        c <- s - a - b
        if (a^2 + b^2 == c^2) {
            found <- TRUE
            break
        }
    }
    if (found) break
}
answer <- a * b * c
print(answer)
 
# Improved Brute Force
a <- 1
b <- 499
repeat{
    c <- sqrt(a^2 + b^2) 
    if (a + b + c > 1000) {b <- b - 1}
    else if (a + b + c < 1000) {a <- a + 1}
    else if (a + b + c == 1000) {break}
}
answer <- a * b * c
print(answer)
** Euclidâ€™s Method
Euclidâ€™s formula generates Pythagorean triples for an arbitrary pair of integers m and n with m > n > 0. The formula states that the integers a = m^2 - n^2, b = 2mn, c = m^2 = n^2 form a Pythagorean triple. View the code below or download the most recent version from GitHub.

#+BEGIN_SRC R
abcsum <- 1000
x <- abcsum / 2
min <- floor(sqrt(x / 2))
max <- ceiling(sqrt(x))
m <- min:max
m <- m[x %% m == 0]
n <- ((x / m) - m)
a <- 2 * m * n
b <- m^2 - n^2
c <- m^2 + n^2
answer <- a * b * c
print(answer)
#+END_SRC
Scatter plot of the legs (a, b) of the first Pythagorean triples with a and b less than 6000. Negative values are included to illustrate the parabolic patterns. By Dearjean13 CC BY-SA 4.0.
* Problem 10: Summation of primes
:PROPERTIES:
:ORDERED:  t
:END:
Euler Problem 10 asks for the summation of primes. Computationally this is a simple problem because we can re-use the prime sieve developed for Euler Problem 3. When generating a large number of primes the erratic pattern at which they occur is much more interesting than their sum. Mathematicians consider primes the basic building blocks of number theory. No matter how hard we look, however, they do not seem to obey any logical sequence.
The summing of primes reveals an interesting problem in mathematics. Goldbachâ€™s conjecture is one of the oldest and best-known unsolved problems in number theory and states that:

    Every even integer greater than 2 can be expressed as the sum of two primes.

Note that this conjecture is only about even numbers. Goldbach also theorised that every odd composite number can be written as the sum of a prime and twice a square.
** Euler Problem 10 Definition

The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17. Find the sum of all the primes below two million.
Solution

The sieve of Eratosthenes function used in Euler Problem 3 can be reused once again to generate the prime numbers between two and two million. An interesting problem occurs when I run the code. When I sum all the primes without the as.numeric conversion, R throws an integer overflow error and recommends the conversion. You can download this code from GitHub.

#+BEGIN_SRC R
primes <- esieve(2e6)
answer <- (sum(as.numeric(primes)))
print(answer)
#+END_SRC
* Learning mode about R
* R Index
| Topic                    | Chapter |
|--------------------------+---------|
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/assignOps.html][Assignment]]               |    1-10 |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Control.html][For]] loop                 |     1,3 |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Colon.html][Regular sequence]] (colon) |       1 |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Arithmetic.html][Arithmetic]]               |    1-10 |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Comparison.html][Relational operators]]     |    1-10 |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/sum.html][sum]]                      |       1 |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/unique.html][unique]]                   |       1 |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Control.html][if, then, else]]           |     1,3 |
| Subsetting []            |     1,2 |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Round.html][Rounding numbers]]         |       1 |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/print.html][Print]] results            |    1-10 |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Control.html][While]]                    |     2,3 |
| max                      |         |
| collection               |         |
| Functions                |         |
| [[https://stat.ethz.ch/R-manual/R-devel/library/base/html/Logic.html][Logic]]                    |     1,3 |
| Data frame               |         |
| Maxima and minima        |       2 |
| length                   |     2,3 |
| Combine                  |       2 |
| functions                |       3 |
| packages                 |       2 |
| plot                     |       7 |
| strins                   |       8 |
| nchar                    |       8 |
| substr                   |       8 |
| prod                     |       8 |
| as.numeric               |       8 |
| strsplit                 |       8 |
| boolean                  |       9 |
| readLines                |      10 |
| lapply                   |      10 |
| matrix                   |      10 |
* Mathematical Index
| Topic                  | Chapter |
|------------------------+---------|
| Arithmetic progression |     1,6 |
| Big-O notation         |       6 |
| Divisibility           |       5 |
| Factorisation          |       5 |
| Fibonacci sequence     |       2 |
| Goldbach conjecture    |      10 |
| Halting problem        |       4 |
| Lychrel numbers        |       4 |
| n-grams                |       8 |
| Palindromic numbers    |       4 |
| Prime factors          |       3 |
| Prime gaps             |       7 |
| Prime numbers          |   7, 10 |
| Pythagorean triples    |       9 |
| Rational numbers       |       5 |
| Sexy primes            |       7 |
| Sieve of Eratosthenes  |       3 |
| Sum of squares         |       6 |
| Twin primes            |       7 |

* Answers
** Fizzbuzz
#+begin_src R
  for (i in 1:100) {
    if (i %% 15 ==0) print("Fizzbuzz")
    else {
      if (i %% 3 == 0) print("Fizz")
      if (i %% 5 == 0) print("Buzz")
    }
  print(i)
  }
#+end_src

#+RESULTS:
